# Proxy template

### Процессы

#### Теоретические вопросы
    1. Что такое fork(2) и что он делает?
    2. Что такое clone(2) и что он делает?
    3. Состояния процесса. Состояние zombie и зачем оно нужно?
    4. Как получить код возврата процесса и что этот код из себя представляет?
    5. Что находится в proc, proc/stat?
    6. Процесс init, зачем он нужен.
    7. Что происходит с дочерними процессами, если родительский умирает?
    8. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит?


### Компиляция и линковка

#### Теоретические вопросы
    1. Из каких этапов состоит компиляция (используйет флаги компилятора и посмотрите промежуточные результаты)?
    2. Что такое elf файл и какие его типы бывают?
    3. Используйте readelf. Посмотрите основные секции elf файла и их назначение.
    4. Статические и динамические библиотеки. Чем отличаются relocateable и shared object файлы.
    5. Как именно происходит подключение символов из динамической библиотеки (секции got, plt).
    6. Различие статической и динамической линковки (посмотрите dlopen и dlsym).
    7. nm и ldd, с какимии секциями elf файла работают? Объяснить вывод.
    8. Как устроена утилита file. Объяснить её вывод.
    9. Чем отличаются секции от сегментов?
    10. Посмотрите зависимости собранного исполняемого файла. Зачем нужен ld-linux.so (секция .interp)?
    11. Зачем может понадобиться утилита strip и objdump?
    12. Как запускается main функция программы?
    13. Зачем нужен флаг компиляции -export-dynamic
    14. При помощи nm посмотрите все символы получившегося исполняемого файла. Как настроить компоновщик, чтобы сохранились 
        все символы, предоставляемые библиотекой config?

#### Задания (порядок выполнения не важен)
    1. Система плагинов:
        a. Напишите тестовый плагин с именем "greeting" в соответсвии с представленным интерфейсом (файл динамической библиотеки плагина должен называться так: "название плагина".so);
        b. Реализуйте все 3 функции плагина:
            - init должна подключать call-back функцию executor_start_hook и писать в stdout "greeting initialized"
            - fini должна отключать executor_start_hook и писать в stdout "greeting finished"
            - name должна возвращать "greeting" 
            Кастомная функция executor_start_hook должна писать в stdout "Hello, world!"
        c. Реализуйте модуль мастер процесса, способный загружать и выгружать плагины во время работы программы; 
            Вызовите executor_start_hook в main. Для демонстрации работы подключите плагин с именем "greeting", пока hardcode.  
    2. Написать статическую библиотеку конфига в соответсвии с интерфейсом:
        a. Реализуйте из него функцию (и только её) int create_config_table(void). Она должна просто возвращать ноль и не делать больше ничего.
    3. Написать динамическую библиотеку логгера в соответствии с интерфейсом:
        b. Реализуйте из него функцию (и только её) int init_logger(char* path, long file_size_limit, int files_limit).
            Она должна просто возвращать ноль и не делать больше ничего, реализовывать проверку аргументов пока не требуется.
           
             
### Файлы и системные вызовы
Лабораторная работа проверяет знания студентов по темам: системные вызовы, файловые системы.

#### Теоретические вопросы
    1. Системные вызовы и механизм их работы.
    2. Что такое файл? Чем отличается файл от дирректории?
    3. Что такое inode и dentry? Их основные поля и зачем они нужны?
    4. Символьные и жесткие ссылки и инструменты для их создания (symlink(2) и link(2)).
    5. Что выводит утилита strace? Используйте её вместе с библиотекой для времени, объясните что происходит.
    6. Зачем нужно vdso?
    7. Что такое файловая система?
    8. Утилиты mount и unmount. Что они делают и зачем нужны?




#### Задания (порядок выполнения не важен)
    1. Реализвать функцию void register_worker(...) в соответсвии с интерфейсом.
        a. Эта функция должна создавать процесс, который начнёт выполнятся с переданной ему функции.
        b. Параметры, которые в неё передаются, должны быть где-то сохранены вместе с pid-ом процесса и
            удалены только при его окночательном завершении.
        c. Основной процесс должен посылать сигнал SIGTERM своим дочерним процессам при завершении.
            Коды возврата дочерних процессов должны корректно обрабатываться.
    2. Написать плагин с названием task_manager, использующий функцию register_worker для создания процесса.
        a. Функция, которая будет запущена в новом процессе должна просто возвращать ноль.
        b. Напишите обработчик сигнала SIGTERM так, чтобы при получении этого сигнала код возврата был 0.

#### Требования к устойчивости
    
    Все ресурсы при заверешнии должны корректно освобождаться (в том числе при сбоях в работе),
    дочерние процессы должны восстанавливаться если это необходимо, должна быть корректная обработка сигналов.